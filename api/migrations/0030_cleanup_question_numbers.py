# Generated by Django 5.0.2 on 2025-12-31 18:29

from django.db import migrations, models
from django.db import transaction


def cleanup_question_numbers(apps, schema_editor):
    """
    Data migration to:
    1. Set question_number = NULL for all unapproved questions
    2. Initialize the counter
    Note: Duplicate question_numbers are allowed for grouped questions
    """
    Question = apps.get_model('api', 'Question')
    QuestionNumberCounter = apps.get_model('api', 'QuestionNumberCounter')
    
    with transaction.atomic():
        # Step 1: Set question_number = NULL for all unapproved questions
        unapproved_count = Question.objects.filter(is_approved=False).exclude(question_number__isnull=True).update(question_number=None)
        print(f"✅ Set question_number to NULL for {unapproved_count} unapproved questions")
        
        # Step 2: Find the maximum question_number among approved questions
        # Note: Multiple questions can share the same question_number (for grouped questions)
        from django.db.models import Max
        max_qnum = Question.objects.filter(
            is_approved=True,
            question_number__isnull=False
        ).aggregate(max_num=Max('question_number'))['max_num'] or 0
        
        max_existing_number = max_qnum
        
        # Step 4: Initialize the counter
        counter, created = QuestionNumberCounter.objects.get_or_create(
            id=1,
            defaults={'last_number': max_existing_number}
        )
        
        if not created:
            # Update if it already exists (shouldn't happen, but be safe)
            counter.last_number = max_existing_number
            counter.save(update_fields=['last_number'])
        
        print(f"✅ Initialized counter with last_number={max_existing_number}")
        
        # Step 3: Reassign numbers to approved questions that have NULL
        # This ensures they get fresh sequential numbers
        # Note: We don't reassign duplicates because grouped questions intentionally share question_number
        questions_to_renumber = Question.objects.filter(
            is_approved=True,
            question_number__isnull=True
        ).order_by('created_at', 'id')
        
        renumbered_count = 0
        for question in questions_to_renumber:
            counter.last_number += 1
            counter.save(update_fields=['last_number'])
            question.question_number = counter.last_number
            question.save(update_fields=['question_number'])
            renumbered_count += 1
        
        if renumbered_count > 0:
            print(f"✅ Reassigned {renumbered_count} approved questions with fresh numbers")


def reverse_cleanup(apps, schema_editor):
    """Reverse migration - cannot fully reverse, but we can at least not break things"""
    # This is a data migration, so we can't fully reverse it
    # The constraint will prevent duplicates going forward anyway
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("api", "0029_add_question_number_counter_and_constraint"),
    ]

    operations = [
        migrations.RunPython(cleanup_question_numbers, reverse_cleanup),
    ]
